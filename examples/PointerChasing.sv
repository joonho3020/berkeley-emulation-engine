// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module mem_8x4(
  input  [2:0] R0_addr,
  input        R0_en,
  input        R0_clk,
  output [3:0] R0_data,
  input  [2:0] W0_addr,
  input        W0_en,
  input        W0_clk,
  input  [3:0] W0_data
);

  reg [3:0] Memory[0:7];
  reg       _R0_en_d0;
  reg [2:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 4'bx;
endmodule

module SRAM(
  input        clock,
  input        io_wr_en,
  input  [2:0] io_wr_addr,
  input  [3:0] io_wr_data,
  input  [2:0] io_rd_addr,
  output [3:0] io_rd_data
);

  mem_8x4 mem_ext (
    .R0_addr (io_rd_addr),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (io_rd_data),
    .W0_addr (io_wr_addr),
    .W0_en   (io_wr_en),
    .W0_clk  (clock),
    .W0_data (io_wr_data)
  );
endmodule

module Chaser(
  input        clock,
  input        reset,
  input        io_start,
  output       io_done,
  output [1:0] io_sram_rd_addr,
  input  [3:0] io_sram_rd_data,
  output [3:0] io_final_addr
);

  reg  [1:0] state;
  reg  [3:0] currentAddr;
  reg  [2:0] step;
  wire       _GEN = state == 2'h0;
  wire       _GEN_0 = state == 2'h1;
  wire       _GEN_1 = _GEN_0 & ~(step[2]);
  always @(posedge clock) begin
    if (reset) begin
      state <= 2'h0;
      step <= 3'h0;
    end
    else if (_GEN) begin
      if (io_start) begin
        state <= 2'h1;
        step <= 3'h0;
      end
    end
    else begin
      if (_GEN_0 & step[2])
        state <= 2'h2;
      if (_GEN_1)
        step <= step + 3'h1;
    end
    if (_GEN) begin
      if (io_start)
        currentAddr <= 4'h0;
    end
    else if (_GEN_1)
      currentAddr <= io_sram_rd_data;
  end // always @(posedge)
  assign io_done = state == 2'h2;
  assign io_sram_rd_addr = _GEN | ~_GEN_1 ? 2'h0 : currentAddr[1:0];
  assign io_final_addr = currentAddr;
endmodule

module PointerChasing(
  input        clock,
  input        reset,
  input        io_start,
  output       io_done,
  output [3:0] io_final_addr
);

  reg        initDone;
  wire [1:0] _chaser_io_sram_rd_addr;
  wire [3:0] _sram_io_rd_data;
  reg  [3:0] initCntr;
  wire [3:0] _initCntr_T = initCntr + 4'h1;
  always @(posedge clock) begin
    if (reset) begin
      initDone <= 1'h0;
      initCntr <= 4'h0;
    end
    else begin
      initDone <= ~initDone & initCntr == 4'h7 | initDone;
      if (initDone) begin
      end
      else
        initCntr <= _initCntr_T;
    end
  end // always @(posedge)
  SRAM sram (
    .clock      (clock),
    .io_wr_en   (~initDone),
    .io_wr_addr (initCntr[2:0]),
    .io_wr_data (_initCntr_T),
    .io_rd_addr ({1'h0, _chaser_io_sram_rd_addr}),
    .io_rd_data (_sram_io_rd_data)
  );
  Chaser chaser (
    .clock           (clock),
    .reset           (reset),
    .io_start        (io_start & initDone),
    .io_done         (io_done),
    .io_sram_rd_addr (_chaser_io_sram_rd_addr),
    .io_sram_rd_data (_sram_io_rd_data),
    .io_final_addr   (io_final_addr)
  );
endmodule

