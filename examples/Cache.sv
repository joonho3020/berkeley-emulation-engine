// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module mem_8x8(
  input  [2:0] RW0_addr,
  input        RW0_en,
  input        RW0_clk,
  input        RW0_wmode,
  input  [7:0] RW0_wdata,
  output [7:0] RW0_rdata
);

  reg [7:0] Memory[0:7];
  reg [2:0] _RW0_raddr_d0;
  reg       _RW0_ren_d0;
  reg       _RW0_rmode_d0;
  always @(posedge RW0_clk) begin
    _RW0_raddr_d0 <= RW0_addr;
    _RW0_ren_d0 <= RW0_en;
    _RW0_rmode_d0 <= RW0_wmode;
    if (RW0_en & RW0_wmode & 1'h1)
      Memory[RW0_addr] <= RW0_wdata;
  end // always @(posedge)
  assign RW0_rdata = _RW0_ren_d0 & ~_RW0_rmode_d0 ? Memory[_RW0_raddr_d0] : 8'bx;
endmodule

module SRAM(
  input        clock,
  input        io_writeEnable,
  input  [2:0] io_writeAddr,
  input  [7:0] io_writeData,
  input  [2:0] io_readAddr,
  output [7:0] io_readData
);

  mem_8x8 mem_ext (
    .RW0_addr  (io_writeEnable ? io_writeAddr : io_readAddr),
    .RW0_en    (1'h1),
    .RW0_clk   (clock),
    .RW0_wmode (io_writeEnable),
    .RW0_wdata (io_writeData),
    .RW0_rdata (io_readData)
  );
endmodule

// VCS coverage exclude_file
module tagMem_8x3(
  input  [2:0] R0_addr,
  input        R0_en,
  input        R0_clk,
  output [2:0] R0_data,
  input  [2:0] W0_addr,
  input        W0_en,
  input        W0_clk,
  input  [2:0] W0_data
);

  reg [2:0] Memory[0:7];
  reg       _R0_en_d0;
  reg [2:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 3'bx;
endmodule

module Cache(
  input        clock,
  input        reset,
  input  [7:0] io_reqAddr,
  input        io_reqRead,
  input        io_reqWrite,
  input  [7:0] io_reqData,
  output [7:0] io_respData,
  output       io_respValid,
  output [7:0] io_memAddr,
  output       io_memRead,
  output       io_memWrite,
  output [7:0] io_memDataOut,
  input  [7:0] io_memDataIn
);

  wire [7:0]      _dataMem_io_readData;
  wire [2:0]      _tagMem_ext_R0_data;
  reg  [1:0]      state;
  reg  [2:0]      reqTagReg;
  reg  [2:0]      reqIndexReg;
  wire            hit = _tagMem_ext_R0_data == io_reqAddr[7:5] & (|_tagMem_ext_R0_data);
  wire            _GEN = state == 2'h0;
  wire            _GEN_0 = ~hit | io_reqRead | ~io_reqWrite;
  wire            _GEN_1 = state == 2'h1;
  wire            _GEN_2 = ~_GEN_1 & (&state);
  wire            _GEN_3 = _GEN_1 | ~(&state);
  wire [7:0]      _GEN_4 = _GEN_3 ? 8'h0 : io_memDataIn;
  wire [3:0][1:0] _GEN_5 = {{2'h0}, {state}, {2'h3}, {hit ? state : 2'h1}};
  always @(posedge clock) begin
    if (reset)
      state <= 2'h0;
    else
      state <= _GEN_5[state];
    if (_GEN) begin
      reqTagReg <= io_reqAddr[7:5];
      reqIndexReg <= io_reqAddr[4:2];
    end
  end // always @(posedge)
  tagMem_8x3 tagMem_ext (
    .R0_addr (io_reqAddr[4:2]),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_tagMem_ext_R0_data),
    .W0_addr (reqIndexReg),
    .W0_en   (~(_GEN | _GEN_1) & (&state)),
    .W0_clk  (clock),
    .W0_data (reqTagReg)
  );
  SRAM dataMem (
    .clock          (clock),
    .io_writeEnable (_GEN ? hit & ~io_reqRead & io_reqWrite : _GEN_2),
    .io_writeAddr
      (_GEN ? (_GEN_0 ? 3'h0 : io_reqAddr[4:2]) : _GEN_3 ? 3'h0 : reqIndexReg),
    .io_writeData   (_GEN ? (_GEN_0 ? 8'h0 : io_reqData) : _GEN_4),
    .io_readAddr    (io_reqAddr[4:2]),
    .io_readData    (_dataMem_io_readData)
  );
  assign io_respData = _GEN ? (hit & io_reqRead ? _dataMem_io_readData : 8'h0) : _GEN_4;
  assign io_respValid = _GEN ? hit & io_reqRead : _GEN_2;
  assign io_memAddr = ~_GEN | hit ? 8'h0 : io_reqAddr;
  assign io_memRead = _GEN & ~hit;
  assign io_memWrite = 1'h0;
  assign io_memDataOut = 8'h0;
endmodule

